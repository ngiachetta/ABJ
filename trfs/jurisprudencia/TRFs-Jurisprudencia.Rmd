---
title: "R Notebook"
output: html_notebook
---

```{r}
library(rvest)
library(httr)
library(purrr)
library(dplyr)
```

```{r}
"http://www.cjf.jus.br/juris/unificada/Resposta"
```

O link acima centraliza as buscas por TRF (e outros), sendo assim, é possível buscar por TRF de interesse e a classe na qual estamos interessados.

As funções abaixo, portanto, baixam os arquivos html de acordo com o TRF.

```{r}
# Funcao para obter o numero (e apenas o numerod) de paginas para rodar um iterador
pages_doc <- function(url){
  max_doc <- url %>% 
    read_html() %>%
    html_nodes(xpath = '//*[@class="informacoes_pesquisa"]//td/span') %>% 
    html_text() %>%
    .[stringr::str_detect(.,'[0-9]')] %>%
    pluck(1) %>% 
    as.numeric()
  ult_pag <- ceiling(max_doc/30)
  
  if(purrr::is_empty(ult_pag)){
    iterador <- 1
  } else{
    iterador <- 2:ult_pag # Pega a partir do 2 pois na funcao busca_TRF ja temos a pagina 1
  }
  
  return(iterador)
}

# Funcao para obter os html das paginas seguintes a partir do que fui obtido no busca_TRF
busca_TRF_pag <- function(url_list, page, class, TRF, path){
  query <- url_list %>% pluck(1) %>% html_session() %>% html_node(xpath = '//input[@name="query"]') %>% html_attr('value')
  if(is.na(query)){
    query <- url_list %>% pluck(1) %>% stringr::str_extract('(?<=query=).*')    
  }

  query_GET_2 <- list(
  query = query,
  pg = page,
  pesquisaAS = "A",
  clas = class,
  tipo_data = "DTJP",
  TRF2 = TRF
  )
  
  if(TRF == "TRF1"){
    names(query_GET_2)[6] <- "TRF1"
  } else if (TRF == "TRF2"){
    names(query_GET_2)[6] <- "TRF2"
  } else if(TRF == "TRF3"){
      names(query_GET_2)[6] <- "TRF3"
  } else if(TRF == "TRF5"){
      names(query_GET_2)[6] <- "TRF5"
  } 
  
  dir.create(path, FALSE, TRUE)
  path <- normalizePath(path)
  file <- stringr::str_c(path, "/page", as.character(page), ".html")
  httr::GET("http://www.cjf.jus.br/juris/unificada/Resposta", query = query_GET_2, httr::config(ssl_verifypeer = FALSE),
            httr::write_disk(file, TRUE))
}

# Funcao que baixa todos os html de acordo com as buscas
busca_TRF <- function(TRF, class = "INQ", path){
  query_GET_1 <- list(
  pesquisaAS = "A",
  clas = class,
  tipo_data = "DTJP",
  TRF2 = TRF
  )
  
  if(TRF == "TRF1"){
    names(query_GET_1)[4] <- "TRF1"
  } else if (TRF == "TRF2"){
    names(query_GET_1)[4] <- "TRF2"
  } else if(TRF == "TRF3"){
      names(query_GET_1)[4] <- "TRF3"
  } else if(TRF == "TRF5"){
      names(query_GET_1)[4] <- "TRF5"
  } 
  
  dir.create(path, FALSE, TRUE)
  path <- normalizePath(path)
  file <- stringr::str_c(path, "/page1.html")
  page1 <- httr::GET("http://www.cjf.jus.br/juris/unificada/Resposta", query = query_GET_1, httr::config(ssl_verifypeer = FALSE),
                     httr::write_disk(file, TRUE))
  
  purrr::map(pages_doc(page1$url), ~busca_TRF_pag(url_list = page1, page = .x,  class, TRF, path))
}
```

Aplicando a função de acordo com o TRF. No nosso caso estamos interessados nos seguintes TRFs:

1. TRF-1

2. TRF-2

3. TRF-3

5. TRF-5

```{r}
trfs <- c("TRF1", "TRF2", "TRF3", "TRF5")
path <- "/home/nathang/Documentos/Scripts and Documents/ESTAGIO_ABJ/ABJ/trfs/jurisprudencia/data-raw/"
path <- purrr::map2_chr(trfs, path, ~stringr::str_c(.y, .x, "/"))

map2(trfs, path, ~busca_TRF(TRF = .x, path = .y))
```

# PARSEANDO OS DADOS

```{r}
trf1_files <- dir(path[1], full.names = T, pattern = "page")
trf2_files <- dir(path[2], full.names = T, pattern = "page")
trf3_files <- dir(path[3], full.names = T, pattern = "page")
trf5_files <- dir(path[4], full.names = T, pattern = "page")
```

```{r}
file_exist <- function(file){
  # Caso o node tenha NA significa que ele existe
  node <- file %>% 
    read_html() %>%
    html_node(xpath = '//input[@id="td_00001"]')
  
  if(is.na(node)){
    return(TRUE)
  } else {
    FALSE
  }
}


parse_trf <- function(file){
  
  stopifnot(file_exist(file) == TRUE)
  
  
  
  data <- file %>%
    xml2::read_html() %>%
    rvest::html_nodes(xpath = '//table[@class="table_pesquisa_lista"]') %>% 
    rvest::html_table(fill = T) %>% 
    .[2:length(.)] %>% # Remove o primeiro df que nao eg necessario para parsear
    purrr::map(~select(.x, colnames(.) %>% dplyr::first())) %>% # Seleciona apenas a primeira coluna de cada df
    purrr::map_dfc(~dplyr::slice(.x, 1:linha)) %>% # Pega a primeiras 18 linhas de cada df e aplca bind_cols
    dplyr::slice(c(-1,-2)) %>% # Remove as duas primeiras linhas
    tibble::rownames_to_column() %>% # Adiciona numero as linhas
    dplyr::mutate(var = sjmisc::is_odd(as.numeric(rowname))) %>% # flag 
    dplyr::select(-rowname)
  
  var_names <- data %>% 
    dplyr::filter(var == T) %>% 
    dplyr::select_(colnames(.) %>% dplyr::first()) %>% 
    purrr::pluck(1) %>% 
    stringr::str_replace_all(" +", "_") %>% 
    stringr::str_to_lower() %>% 
    abjutils::rm_accent()
  
  data <- data %>% 
    dplyr::filter(var == F) %>% 
    dplyr::select(-var) %>% 
    tidyr::gather() %>% 
    magrittr::set_names(c("doc_index", "val")) %>% 
    mutate(key = rep(var_names, nrow(.)/length(var_names))) %>% 
    tidyr::spread(key, val) %>% 
    dplyr::distinct(inteiro_teor, .keep_all = TRUE) %>% 
    dplyr::select(-doc_index) %>% 
    dplyr::mutate(files = file)
  
  return(data)

}

trf2 <- map_dfr(trf2_files, ~parse_trf(.x))
trf3 <- map_dfr(trf3_files[1], ~parse_trf(.x)) # Nao 
trf5 <- map_dfr(trf5_files, ~parse_trf(.x)) # Nao
```

A funcao acima só esta funcionando para o TRF2, pois ele possui um padrão entre os df.

```{r}
lista_df <-trf5_files[1] %>%
  xml2::read_html() %>%
  rvest::html_nodes(xpath = '//table[@class="table_pesquisa_lista"]') %>% 
  rvest::html_table(fill = T) %>% 
  .[2:length(.)] %>% 
  purrr::map(~select(.x, colnames(.) %>% dplyr::first())) 

arruma_lista_trf5 <- function(lista){

}


for(i in 1:length(lista_df)){
  if(nrow(lista_df[[i]]) == 53){
    lista_df[[i]] <- dplyr::slice(lista_df[[i]], 1:26)
  } else if(nrow(lista_df[[i]]) == 49){
    lista_df[[i]] <- dplyr::slice(lista_df[[i]], 1:24) %>% 
      dplyr::bind_rows(tibble(rep(NA,2))) %>% select(colnames(.) %>% dplyr::first())
  } else if(nrow(lista_df[[i]]) == 45){
    lista_df[[i]] <- dplyr::slice(lista_df[[i]], 1:22) %>% 
      dplyr::bind_rows(tibble(rep(NA,4))) %>% select(colnames(.) %>% dplyr::first())
  }
}

purrr::map_dfc(lista_df, ~dplyr::slice(.x, c(-1,-2)))
```

