---
title: "R Notebook"
output: html_notebook
---

```{r}
library(rvest)
library(httr)
library(purrr)
library(dplyr)
```

```{r}
"http://www.cjf.jus.br/juris/unificada/Resposta"
```

O link acima centraliza as buscas por TRF (e outros), sendo assim, é possível buscar por TRF de interesse e a classe na qual estamos interessados.

As funções abaixo, portanto, baixam os arquivos html de acordo com o TRF.

```{r}
# Funcao para obter o numero (e apenas o numerod) de paginas para rodar um iterador
pages_doc <- function(url){
  max_doc <- url %>% 
    read_html() %>%
    html_nodes(xpath = '//*[@class="informacoes_pesquisa"]//td/span') %>% 
    html_text() %>%
    .[stringr::str_detect(.,'[0-9]')] %>%
    pluck(1) %>% 
    as.numeric()
  ult_pag <- ceiling(max_doc/30)
  
  if(purrr::is_empty(ult_pag)){
    iterador <- 1
  } else{
    iterador <- 2:ult_pag # Pega a partir do 2 pois na funcao busca_TRF ja temos a pagina 1
  }
  
  return(iterador)
}

# Funcao para obter os html das paginas seguintes a partir do que fui obtido no busca_TRF
busca_TRF_pag <- function(url_list, page, class, TRF, path){
  query <- url_list %>% pluck(1) %>% html_session() %>% html_node(xpath = '//input[@name="query"]') %>% html_attr('value')
  if(is.na(query)){
    query <- url_list %>% pluck(1) %>% stringr::str_extract('(?<=query=).*')    
  }

  query_GET_2 <- list(
  query = query,
  pg = page,
  pesquisaAS = "A",
  clas = class,
  tipo_data = "DTJP",
  TRF2 = TRF
  )
  
  if(TRF == "TRF1"){
    names(query_GET_2)[6] <- "TRF1"
  } else if (TRF == "TRF2"){
    names(query_GET_2)[6] <- "TRF2"
  } else if(TRF == "TRF3"){
      names(query_GET_2)[6] <- "TRF3"
  } else if(TRF == "TRF5"){
      names(query_GET_2)[6] <- "TRF5"
  } 
  
  dir.create(path, FALSE, TRUE)
  path <- normalizePath(path)
  file <- stringr::str_c(path, "/page", as.character(page), ".html")
  httr::GET("http://www.cjf.jus.br/juris/unificada/Resposta", query = query_GET_2, httr::config(ssl_verifypeer = FALSE),
            httr::write_disk(file, TRUE))
}

# Funcao que baixa todos os html de acordo com as buscas
busca_TRF <- function(TRF, class = "INQ", path){
  query_GET_1 <- list(
  pesquisaAS = "A",
  clas = class,
  tipo_data = "DTJP",
  TRF2 = TRF
  )
  
  if(TRF == "TRF1"){
    names(query_GET_1)[4] <- "TRF1"
  } else if (TRF == "TRF2"){
    names(query_GET_1)[4] <- "TRF2"
  } else if(TRF == "TRF3"){
      names(query_GET_1)[4] <- "TRF3"
  } else if(TRF == "TRF5"){
      names(query_GET_1)[4] <- "TRF5"
  } 
  
  dir.create(path, FALSE, TRUE)
  path <- normalizePath(path)
  file <- stringr::str_c(path, "/page1.html")
  page1 <- httr::GET("http://www.cjf.jus.br/juris/unificada/Resposta", query = query_GET_1, httr::config(ssl_verifypeer = FALSE),
                     httr::write_disk(file, TRUE))
  
  purrr::map(pages_doc(page1$url), ~busca_TRF_pag(url_list = page1, page = .x,  class, TRF, path))
}
```

Aplicando a função de acordo com o TRF. No nosso caso estamos interessados nos seguintes TRFs:

1. TRF-1

2. TRF-2

3. TRF-3

5. TRF-5

```{r}
trfs <- c("TRF1", "TRF2", "TRF3", "TRF5")
path <- "/home/nathang/Documentos/Scripts and Documents/ESTAGIO_ABJ/ABJ/trfs/jurisprudencia/data-raw/"
path <- purrr::map2_chr(trfs, path, ~stringr::str_c(.y, .x, "/"))

map2(trfs, path, ~busca_TRF(TRF = .x, path = .y))
```

# PARSEANDO OS DADOS

```{r}
trf1_files <- dir(path[1], full.names = T, pattern = "page")
trf2_files <- dir(path[2], full.names = T, pattern = "page")
trf3_files <- dir(path[3], full.names = T, pattern = "page")
trf5_files <- dir(path[4], full.names = T, pattern = "page")
```

```{r}
file_exist <- function(file){
  # Caso o node tenha NA significa que ele existe
  node <- file %>% 
    read_html() %>%
    html_node(xpath = '//input[@id="td_00001"]')
  
  if(is.na(node)){
    return(TRUE)
  } else {
    FALSE
  }
}


parse_trf <- function(file){
  
  stopifnot(file_exist(file) == TRUE)
  
  node <- file %>% xml2::read_html()
  
  data <- node %>%
    rvest::html_nodes(xpath = '//table[@class="table_pesquisa_lista"]') %>% 
    rvest::html_table(fill = T) %>% 
    .[2:length(.)] %>% # Remove o primeiro df que nao eg necessario para parsear
    purrr::map(~select(.x, colnames(.) %>% dplyr::first())) %>% # Seleciona apenas a primeira coluna de cada df
    purrr::map_dfc(~dplyr::slice(.x, 1:18)) %>% # Pega a primeiras 18 linhas de cada df e aplca bind_cols, #Achei uma solucao melhor com dplyr::distinct
    dplyr::slice(c(-1,-2)) %>% # Remove as duas primeiras linhas
    tibble::rownames_to_column() %>% # Adiciona numero as linhas
    dplyr::mutate(var = sjmisc::is_odd(as.numeric(rowname))) %>% # flag 
    dplyr::select(-rowname)
  
  var_names <- data %>% 
    dplyr::filter(var == T) %>% 
    dplyr::select_(colnames(.) %>% dplyr::first()) %>% 
    purrr::pluck(1) %>% 
    stringr::str_replace_all(" +", "_") %>% 
    stringr::str_to_lower() %>% 
    abjutils::rm_accent()
  
  data <- data %>% 
    dplyr::filter(var == F) %>% 
    dplyr::select(-var) %>% 
    tidyr::gather() %>% 
    magrittr::set_names(c("doc_index", "val")) %>% 
    mutate(key = rep(var_names, nrow(.)/length(var_names))) %>% 
    tidyr::spread(key, val) %>% 
    dplyr::distinct(inteiro_teor, .keep_all = TRUE) %>% 
    dplyr::select(-doc_index) %>% 
    dplyr::mutate(files = file)
  
  return(data)

}

trf2 <- map_dfr(trf2_files, ~parse_trf(.x))
trf3 <- map_dfr(trf3_files[1], ~parse_trf(.x)) # Nao 
trf5 <- map_dfr(trf5_files, ~parse_trf(.x)) # Nao
```

A funcao acima só esta funcionando para o TRF2, pois ele possui um padrão entre os df. Sendo assim, temos que pensar como podemos generalizar para os outros TRFs. A solução encontrada está no código abaixo:

```{r}
parse_trfs <- function(file){
  node <- file %>% xml2::read_html()
  
  num_processo <- node %>%  html_nodes(xpath = '//div[@class="barra_titulo"]/label/font/input') %>%
    html_attr("value") %>% unique() %>% stringr::str_replace_all("Processo +", "") # IMPORTANTE POREM NAO ESTA NO RESULTADO FINAL
  
  data <- node %>%
    rvest::html_nodes(xpath = '//table[@summary="Lista detalhada de jurisprudência unificada"]') %>% 
    rvest::html_table(fill = T)
  
  num_linha <- purrr::map_dbl(data, nrow) %>% unique() # Existe estes padroes de linhas
  num_linha_value <- purrr::map_dbl(data, nrow)
  num_linha_index <- list()
  for(i in 1:length(num_linha)){
    num_linha_index[[i]] <- which(num_linha_value == num_linha[i])  
  }

  parse_data <- function(data, index){
    data <- data[num_linha_index[[index]]] %>% 
      bind_cols() %>% 
      tibble::rownames_to_column() %>% # Adiciona numero as linhas
      dplyr::mutate(var = sjmisc::is_odd(as.numeric(rowname))) %>% # flag 
      dplyr::select(-rowname)
  
    var_names <- data %>% 
      dplyr::filter(var == T) %>% 
      dplyr::select_(colnames(.) %>% dplyr::first()) %>% 
      purrr::pluck(1) %>% 
      stringr::str_replace_all(" +", "_") %>% 
      stringr::str_to_lower() %>% 
      abjutils::rm_accent()
  
    data <- data %>% 
      dplyr::filter(var == F) %>% 
      dplyr::select(-var) %>% 
      tidyr::gather() %>% 
      magrittr::set_names(c("doc_index", "val")) %>% 
      mutate(key = rep(var_names, nrow(.)/length(var_names))) %>% 
      tidyr::spread(key, val) %>% 
      dplyr::distinct(processo, inteiro_teor, .keep_all = TRUE) %>% 
      dplyr::select(-doc_index) %>% 
      dplyr::mutate(files = file)
  }

  data <- purrr::map_dfr(1:length(num_linha_index), ~parse_data(data, .x)) %>% 
    dplyr::bind_cols(., tibble::tibble(num_processo = num_processo))
}
  

trf2 <- map_dfr(trf2_files, ~parse_trfs(.x))
trf3 <- map_dfr(trf3_files[1], ~parse_trfs(.x)) 
trf5 <- map_dfr(trf5_files, ~parse_trfs(.x)) 

readr::write_rds(trf2, path = "data-raw/rds_data/trf2.rds")
readr::write_rds(trf3, path = "data-raw/rds_data/trf3.rds")
readr::write_rds(trf5, path = "data-raw/rds_data/trf5.rds")
```

